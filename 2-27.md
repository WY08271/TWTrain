##2.27周总结
---
培训开始的第一周, 学习了很多基础性的知识.

####语言的发展
* 现代编程语言的鼻祖可以分为两大类Fortran 和 Lisp.
* 这两者的区别:Fortran是机器友好的编译型语言, 因为在执行代码前需要提前预编译, 所以不宜出错, 虽然编程的效率高但是可读性非常差. 因为之前计算机的性能很差, 硬件设施非常贵, 人们想方设法节约内存去提高运行效率, 代码变得十分复杂. 经过发展衍生出了 JAVA C C++ 等静态语言.
* Lisp 是人脑友好的解释性语言, 效率高, 但是性能很低. 但是在硬件十分便宜的今天, 人们更愿意去消耗硬件资源来获取更少的时间花费. 在 Lisp 中函数十分重要, 有"函数式一等公民"的说法. 经过发展衍生出来 Ruby JavaScript Pathyn 等脚本语言.

####如何快速学好一门语言
* 在学习语言时, 一般应该从这三个方面入手: **数据,过程,语法**.掌握了基础之后可以熟悉常用的 API等, 最重要的是多用, 出现错误自己解决印象才可以更深.

####版本管理的发展
* 从手工管理文件到 CVS, 再由 CVS 到分布式版本管理控制.
* CVS是 central version system .之所以会创建这种种版本控制是为了解决多人合作项目的问题. 在还没有 CSV 时, 个人写项目只能通过副本的方式去记录每次更新的版本, 不便于比较每种版本之间的差异; 多人合作的项目也不方便进行. 由此产生了 CVS. 它有一个 server 端, 所有人通过 checkout(迁出) 和 checkin( 迁入) 代码来保证每次都能获取到整个项目最新的代码, 但是在 checkout 和 checkin 时候是需要网络连通的, 在没网的情况下获取不到最新代码, 无法进行修改. 当两个人同时 checkout 代码进行修改, 改变了同一个文件的同一行代码, 再同时进行 checkin 时会产生冲突, 这个时候其中的一个人就要解决冲突, 再次进行 checkin.
* 由于CVS的很多不便, 比如说必须联网, 与 Linux 的开原协议相违背, 中心仓库挂掉等种种原因. 一位大神看不下去了, 用了一周的时间写出了**分布式的版本管理工具 Git**
* 相比较 CVS 而言, Git 少了 server 端, 每个人都有一个独立的repo(local 和 remote). 每个库都有一套完整的代码, 库与库之间相互独立. 在分布式版本控制中, 不存在中心仓库, 所以不会有中心仓库挂掉代码全都不见的情况, 相反每个人都可以作为一个 remote repo(只要是在远程仓库挂掉前最后提交的人的仓库就包含了最新代码). 在 local repo 里经常用到的两个命令是 git add 和 git commit. 在 remote repo 中经常用到的两个命令是 git pull 和 git push.

####单元测试
* developer's tests 开发者写的测试主要包括了三种, unit test, integration test, ene-to-end test.QA主要包括的测试是验收测试, 与 end-to-end test 主要区别就是人员和场景不同, 其他具体测试方面上的要求都差不多一样.
* 在一个面向对象的系统中, 我们可以把整个系统划分为不同的层, 比如说三层架构中的数据访问层, 业务逻辑层, 表现层, 整个系统中的类又可以分为 worker class 和 manager class, 当系统的使用者去使用这个系统时, 首先要用到的是 manager class 再由它去调用 worker class. 这里 worker class 主要是实现具体的功能, 而 manager class主要起到了调用的功能.
* 测试最重要的两个名词是 SUT 待测系统, DOC 所依赖组件. SUT 和 DOC 总是在粒度上保持一致, 也就是说 SUT 是函数, DOC 也是函数, SUT是类, DOC 也是类. 一个 SUT 可能有多个 DOC. 一般来说 manager class 有 DOC,而 worker class 没有 DOC.
* unit test 一般来说, 在面向对象中的粒度主要是类, 在面向函数和面向过程中的粒度主要是函数.在 unit test 中, 一般不跨层去进行测试.unit test 有两个要求, 1.容易书写, 运行足够快. 2.一个测试用例不影响另外一个测试用例, 保证每个测试相互隔离, 这样可以提高开发速度. 为了使它运行快, 必须排除慢的因素, 比如: 网络访问, 数据库连接, 这里可以使用**test double测试替身**. unit test 是为了测试行为.
* 集成测试,一般来说是测试跨层的依赖是否通过测试, 运行的比较慢.
* end-to-end test 是系统级别的测试, 用户行为的开始到结束是否符合预期.通常来说与验收测试相同.
* 测试金字塔, 在数量上来说 unit test最多, end-to-end test 最少; 在覆盖关系上, ent-to-end test 可以涵盖 unit test. 那什么时候写 unit test 和 end-to-end test 呢? 这是个信仰问题. 但是和开发效率, 成本等问题有关. 自己决定是否有必要写测试, 是否会帮助提高开发速度.
* 高级测试如果可以覆盖低级测试的话, 为什么还要写低级测试. 低级测试可以提高反馈速度, 提高开发速度. 而高级测试可以快速检测出包含错误, 却不能定位错误.

####管道思维(pipeline)
* 管道思维可以通过水管的工作去理解, 一段水管肯定有一端是进水端一端是出水端, 水管在管道的内部发生了什么样的变化我们是看不到的,但是可以通过多段水管的拼接, 将水源从一处运送到另一处. 在程序中也是一样, 每个函数或者模块可以看做是一段水管, 有输入有输出, 将多段水管拼接起来可定会有这样一种情况, 一端水管的输出是另一端水管的输入.
* 使用 pipeline 的主要作用有两点: 1.可以从结果倒推回 input,检测思考问题的正确性. 2.在编写代码前, 只需要想清楚大概的处理流程就好, 怎样从输入到输出可以暂时不用考虑.

####tasking
* **tasking 是什么?** 一种可以让人快速, 清晰知道你思考问题,解决问题的方式. tasking 也可以说是一种沟通方式.
* **tasking 什么时候用?** 在着手编写代码之前, 也就是分析问题的时候用 tasking. 只有分析清楚问题应该如何去, 每一步应该做什么, 在开始编写代码的时候才会有目的性, 不至于出错都找不到原因.
* **tasking 用在什么地方?** 分析问题的时候, 需要同其他人将自己思路时.
* **为什么要用 tasking?** 方便团队间的沟通交流, 方便别人清楚写 tasking 人的思路, 也可以快速找出隐藏的问题和不合常理处, 方便写测试.
* **谁需要用 tasking?** 自己, 团队之间.
* **tasking 该怎么用?**
>1. tasking 就是一种分析问题的方式, 以 POS 机为例. 在对 POS 机问题进行分析时, 应该从结果入手, 逆向思维思考问题, 推导出需要的步骤以及过程.
>1. 每一个 task 都要包括有名称, 输入, 输出, 输入的结构, 输出的结构.
>2. 考虑清楚每一步的 task 应该做什么, 控制每一个 task 在15min以内, 只有清楚的知道 task 是做什么的, 才能快速根据 task 写代码. 如果一个 task 太大, 在15min内没有办法写完, 要想办法去拆分 task. 但是不要过分关注细节上的东西.
>3. 在 task 里, 输入和输出的数据结构非常重要, 务必要将数据结构写清楚, 除了计算出来的数值等, 没有数据是凭空产生的, 输出里新增加了一项东西, 肯定要在输入中找到.

* **POS例子**

>输出:

```
***<没钱赚商店>收据***
名称：可口可乐，数量：3瓶，单价：3.00(元)，小计：6.00(元)
名称：羽毛球，数量：5个，单价：1.00(元)，小计：4.00(元)
名称：苹果，数量：2斤，单价：5.50(元)，小计：11.00(元)
----------------------
总计：21.00(元)
节省：4.00(元)
**********************
```
>输入:

```javascript
[
  'ITEM000001',
  'ITEM000001',
  'ITEM000001',
  'ITEM000001',
  'ITEM000001',
  'ITEM000003-2',
  'ITEM000005',
  'ITEM000005',
  'ITEM000005'
]
```

其中对'ITEM000003-2'来说，"-"之前的是标准的条形码，"-"之后的是数量。
当我们购买需要称量的物品的时候，会由称量的机器生成此类标签（Tag），收银机负责识别生成收据。

>提示:

1. 可使用```loadAllItems()```方法获取全部的商品，该方法返回结果为一个包含了商品对象的数组（样例）：

   ```
   [ item1, item2, item3, ..., itemN ]
   ```

2. 每一个商品对象的结构如下（样例）：

   ```javascript
   {
      barcode: 'ITEM000000',
      name: '可口可乐',
      unit: '瓶',
      price: 3.00
   }
   ```

3. 可使用```loadPromotions()```方法获取全部的促销信息，该方法返回结果为一个包含有促销信息对象的数组（样例）：

   ```javascript
   [
      {
        type: 'BUY_TWO_GET_ONE_FREE',
        barcodes: [
          'ITEM000000',
          'ITEM000001'
        ]
      },
      {
        type: 'OTHER_PROMOTION',
        barcodes: [
          'ITEM000003',
          'ITEM000004'
        ]
      }
   ]
   ```

>分析 POS机 :

1. 从结果可以看出我们需要的是打印出商品的"名称：可口可乐，数量：3瓶，单价：3.00(元)，小计：6.00(元)"信息及总花费和节省, 从信息上来看, 除了小计,总价,总节省是通过计算得到的, 其他信息都可以从输入中获得. 所以这一步输出起名字叫做 ReceiptItem({CartItem: Object, subTotal: XXX, XXX: XXX}). 输入可以看做是 CartItem({Item: Object, count:XXX}).
2. 前一步的输出是后一步的输入, loadAllitem() 的 item 有 barcode, unit, price, name 四种属性正好对应了CartItem 的 item 的属性, 所以这一步的输入肯定有 loadAllItems() 中每一个商品的结构. cartItem 中的 count 可以通过看出是通过计算 tags 得到的.

```
   task1 : getCartItems()

   输入: tags  ['ITEM000001','ITEM000001']

   输出: cartItem [{item: Object, count: float}]

   task2 : getReceiptItems()

   输入: cartItem [{item: Object, count: float}]

   输出: ReceiptItem[{CartItem: Object, subTotal: XXX, XXX: XXX}]

   task3 : receipt()

   输入: ReceiptItem[{CartItem: Object, subTotal: XXX, XXX: XXX}]

   输出: result
```

>总结写 tasking 出现的问题

1. 看问题进行分析时, 首先应该从大的方面去考虑, 不应该过早的陷入细节. 整体思路理清楚后, 再去尽心细节上的完善.
2. 在写 task 的时候要保证数据结构的清晰, 谨记 task 是用来处理数据结构的, 如果输入和输出的数据结构都一样, 这个 task 可能就仅仅只是一个子 task 或者数据结构出错.
3. 数据结构是用来传递的, 不要轻易给结构动态添加一个属性, 会在以后维护的过程中带来非常大的不便.(比如出现undefined错误找不到原因).
4. 将一个大的 task 拆分为小 task 时, 数据结构可能会发生改变. 比如将一个类中的方法提出来, 对应类的参数就要发生改变.
5. 代码多并不一定代表逻辑复杂, 在进行细节分析的时候要考虑清楚 task 是不是能够保证在15min内完成.
6. 我们写 tasking 的目的是为了帮助我们理清楚思路同时方便和他人进行交流沟通. 在平时写程序时, 常常看需求, 粗略思考应该怎样解决这个问题, 并没有细致到考虑清楚输入输出以及每个步骤的名字, 首先这种情况下写代码脑袋就会燃成浆糊, 出现问题也定位不到问题的原因和出处, 其次假设顺利写出代码, 肯定会对代码进行适当的更改, 难免会出现一些问题, 有可能还会把写好的代码改坏. 写 task 可以保证在写代码的时候有清晰的思路, 因为在写 task 时已经理清楚了问题的处理方式, 在输入输出都清楚的情况下, 很容易就可以写 unit test, 有了测试的前提, 就可以进行重构了. 如果说分析, 设计, 测试, 实现, 重构是一整套流程的话, tasking 就是将花费在测试, 实现, 重构上无意义的时间用在了分析和设计上.
7. 对于 tasking 的思考: 1.都说 tasking 是为了方便别人清楚的知道你的思路, 在编写代码前想清楚每个步骤应该做什么. 这仅仅是对于个人而言的优势. 如果一个团队一起去共同完成 POS机, 每个人和每个人的想法千差万别, 根本没有办法一概而论. 所以说, tasking 是不是仅仅只适用于自己的思考或者和别人的沟通, 并不适合团队里共同使用? 2.junior 对划分 task 可能不是那么顺利(估计是因为一直在模仿机器思考问题), 如果在自己动手写 task 的时候, 怎么才能发现错误? 如果发现不出错误就开始写程序, 不就和没使用 tasking 是一个效果么?
